import { GltfData } from "../GltfData";

import { ValidationIssue } from "../../ValidationIssue";
import { ValidationIssueSeverity } from "../../ValidationIssueSeverity";
import { GltfExtensionIssues } from "../GltfExtensionIssues";

/**
 * A class for processing the list of issues that are generated by
 * the glTF validator, to filter out the issues that are obsolete
 * due to the validation from the ExtStructuralMetadataValidator.
 *
 * @internal
 */
export class ExtStructuralMetadataIssues {
  /**
   * Process the given list of validation issues, and possibly filer
   * out the issues that are obsolete due to the validation that
   * is performed by 'validateGltf'.
   *
   * @param path - The path for validation issues
   * @param gltfData - The GltfData objects
   * @param causes - The validation issues
   */
  static async processCauses(
    path: string,
    gltfData: GltfData,
    causes: ValidationIssue[]
  ): Promise<ValidationIssue[]> {
    const usedBufferViewIndices =
      ExtStructuralMetadataIssues.computeUsedBufferViewIndices(gltfData.gltf);
    const usedTextureIndices =
      ExtStructuralMetadataIssues.computeUsedTextureIndices(gltfData.gltf);

    const processedCauses: ValidationIssue[] = [];
    for (const cause of causes) {
      const remove = await ExtStructuralMetadataIssues.shouldRemove(
        usedBufferViewIndices,
        usedTextureIndices,
        cause
      );
      if (!remove) {
        processedCauses.push(cause);
      }
    }
    return processedCauses;
  }

  /**
   * Returns whether the given issue is an issue that should be removed
   * because it is obsolete due to the validation that is performed by
   * 'validateGltf'
   *
   * @param usedBufferViewIndices - The buffer view indices that are
   * actually used by the extension, via properties from the
   * property tables
   * @param usedTextureIndices - The texture indices that are
   * actually used by the extension, via properties from the
   * property textures
   * @param issue - The validation issue
   * @returns Whether the issue should be removed
   */
  private static async shouldRemove(
    usedBufferViewIndices: number[],
    usedTextureIndices: number[],
    issue: ValidationIssue
  ): Promise<boolean> {
    // Never remove errors!
    if (issue.severity === ValidationIssueSeverity.ERROR) {
      return false;
    }

    // Remove the message about the extension not being supported
    const isIssueAboutUnsupportedExtension =
      GltfExtensionIssues.isIssueAboutUnsupportedExtension(
        issue,
        "EXT_structural_metadata"
      );
    if (isIssueAboutUnsupportedExtension) {
      return true;
    }

    // Remove all INFO- and WARNING issues about unused objects
    // for buffer views and textures that are actually used
    // by the extension
    const isObsoleteAboutBufferView =
      GltfExtensionIssues.isObsoleteIssueAboutUnusedObject(
        issue,
        "bufferViews",
        usedBufferViewIndices
      );
    if (isObsoleteAboutBufferView) {
      return true;
    }
    const isObsoleteAboutTexture =
      GltfExtensionIssues.isObsoleteIssueAboutUnusedObject(
        issue,
        "textures",
        usedTextureIndices
      );
    if (isObsoleteAboutTexture) {
      return true;
    }
    return false;
  }

  /**
   * Pragmatically drill into the given glTF object to find all bufferView
   * indices that are used via properties of property tables.
   *
   * This will fall back to empty objects and arrays everywhere, and return
   * only the indices that are definitely known to be used.
   *
   * @param gltf - The glTF JSON object
   * @returns The buffer view indices that are used by the
   * EXT_structural_metadata extension
   */
  private static computeUsedBufferViewIndices(gltf: any): number[] {
    const bufferViewIndices: number[] = [];
    const extensions = gltf.extensions ?? {};
    const extension = extensions["EXT_structural_metadata"] ?? {};
    const propertyTables = extension.propertyTables ?? [];
    for (const propertyTable of propertyTables) {
      const properties = propertyTable.properties ?? {};
      for (const property of Object.values(properties)) {
        const p = property as any;
        const valuesBufferViewIndex = p.values;
        const stringOffsetsBufferViewIndex = p.stringOffsets;
        const arrayOffsetsBufferViewIndex = p.arrayOffsets;
        if (typeof valuesBufferViewIndex === "number") {
          bufferViewIndices.push(valuesBufferViewIndex);
        }
        if (typeof stringOffsetsBufferViewIndex === "number") {
          bufferViewIndices.push(stringOffsetsBufferViewIndex);
        }
        if (typeof arrayOffsetsBufferViewIndex === "number") {
          bufferViewIndices.push(arrayOffsetsBufferViewIndex);
        }
      }
    }
    return bufferViewIndices;
  }

  /**
   * Pragmatically drill into the given glTF object to find all texture
   * indices that are used via properties of property textures.
   *
   * This will fall back to empty objects and arrays everywhere, and return
   * only the indices that are definitely known to be used.
   *
   * @param gltf - The glTF JSON object
   * @returns The texture indices that are used by the
   * EXT_structural_metadata extension
   */
  private static computeUsedTextureIndices(gltf: any): number[] {
    const textureIndices: number[] = [];
    const extensions = gltf.extensions ?? {};
    const extension = extensions["EXT_structural_metadata"] ?? {};
    const propertyTextures = extension.propertyTextures ?? [];
    for (const propertyTexture of propertyTextures) {
      const properties = propertyTexture.properties ?? {};
      for (const property of Object.values(properties)) {
        const p = property as any;
        const textureIndex = p.index;
        if (typeof textureIndex === "number") {
          textureIndices.push(textureIndex);
        }
      }
    }
    return textureIndices;
  }
}
