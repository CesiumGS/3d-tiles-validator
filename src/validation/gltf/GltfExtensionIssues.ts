import { ValidationIssue } from "../ValidationIssue";
import { GltfData } from "./GltfData";

import { ValidationIssues } from "../../issues/ValidationIssues";

/**
 * Functions for implementing filters on lists of validation issues,
 * to filter out issues that are obsolete due to glTF validation
 * steps that are performed by the 3D Tiles validator.
 */
export class GltfExtensionIssues {
  /**
   * Process the given list of issues in view of KHR_texture_basisu.
   *
   * This will omit the issues that are considered obsolete due to
   * the lack of support for KHR_texture_basisu validation. If any
   * issues have been filtered out, a single, summarizing issue will
   * be added to the list, saying that the result was filtered.
   *
   * @param path - The path for validation issues
   * @param gltfData - The GltfData
   * @param causes - The causes
   * @returns The filtered causes
   */
  static async processCausesKhrTextureBasisu(
    path: string,
    gltfData: GltfData,
    causes: ValidationIssue[]
  ): Promise<ValidationIssue[]> {
    const gltf = gltfData.gltf;
    const khrTextureBasisuImageIndices =
      GltfExtensionIssues.computeImageIndicesKhrTextureBasisu(gltf);

    const processedCauses: ValidationIssue[] = [];
    for (const cause of causes) {
      const remove = await GltfExtensionIssues.shouldRemoveKhrTextureBasisu(
        khrTextureBasisuImageIndices,
        cause
      );
      if (!remove) {
        processedCauses.push(cause);
      }
    }

    if (causes.length > processedCauses.length) {
      const numRemoved = causes.length - processedCauses.length;
      const message =
        "Omitted " +
        numRemoved +
        " issues that have been " +
        "created due to the lack of support of the KHR_texture_basisu " +
        "extension in the glTF validator";
      const summaryIssue = ValidationIssues.VALIDATION_INFO(path, message);
      processedCauses.push(summaryIssue);
    }
    return processedCauses;
  }

  /**
   * Returns whether the given issue is an issue that should be removed
   * because it is caused by the lack of support of the KHR_texture_basisu
   * extension in the glTF validator.
   *
   * @param khrTextureBasisuImageIndices - The indices of images that
   * are used by the KHR_texture_basisu extension
   * @param issue - The validation issue
   * @returns Whether the issue should be removed
   */
  private static async shouldRemoveKhrTextureBasisu(
    khrTextureBasisuImageIndices: number[],
    issue: ValidationIssue
  ): Promise<boolean> {
    const message = issue.message;
    const path = issue.path;

    // Remove the message about KHR_texture_basisu not being supported
    const unsupportedExtensionName =
      GltfExtensionIssues.extractUnsupportedExtensionName(message);
    if (unsupportedExtensionName === "KHR_texture_basisu") {
      return true;
    }

    // Remove all issues about
    // - invalid KTX MIME type
    // - unrecognized image format
    // - unused object
    // for issues that refer to a path starting with "/images/N"
    // where N is one of the images that are referred to by
    // the KHR_texture_basisu extension in any texture.
    if (
      message.startsWith("Invalid value 'image/ktx2'.") ||
      message.startsWith("Image format not recognized.") ||
      message.startsWith("This object may be unused.")
    ) {
      const imageIndex = GltfExtensionIssues.extractIndex("images", path);
      if (imageIndex === undefined) {
        // This is making some assumptions about the path that
        // is generated by the glTF validator. Just print a
        // warning for the case that this ever breaks.
        console.warn("Could not extract image index from path: " + path);
        return false;
      }
      if (khrTextureBasisuImageIndices.includes(imageIndex)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Compute the indices of all images that appear as any
   * <code>gltf.textures[i].extensions["KHR_texture_basisu"].source</code>.
   *
   * @param gltf - The glTF JSON object
   * @returns The image indices
   */
  private static computeImageIndicesKhrTextureBasisu(gltf: any): number[] {
    const imageIndices = [];
    const textures = gltf.textures ?? [];
    for (const texture of textures) {
      const extensions = texture.extensions ?? {};
      const khrTextureBasisuExtension = extensions["KHR_texture_basisu"] ?? {};
      const source = khrTextureBasisuExtension.source;
      if (typeof source === "number") {
        imageIndices.push(source);
      }
    }
    return imageIndices;
  }

  /**
   * Tries to extract the index of the top-level element that is
   * indicated by the given JSON path.
   *
   * The given path is a JSON path that is generated by the glTF validator,
   * for example
   * "/images/4/mimeType"
   *
   * This function will omit the prefix, and (if present) the part
   * starting with the subsequent slash, and return the resulting
   * element ("4" in this example) as a number, if it is in fact
   * a number.
   *
   * If any aspect of this parsing does not succeed, then <code>undefined</code>
   * is returned. Yes, this could be solved with a 1.5MB "JSON path" dependency.
   * Let's be pragmatic for now.
   *
   * @param topLevelName - The name of the top-level type (e.g. 'images'
   * or 'accessors')
   * @param path - The path as generated by the glTF validator
   * @returns The index
   */
  private static extractIndex(
    topLevelName: string,
    path: string
  ): number | undefined {
    const prefix = "/" + topLevelName + "/";
    if (!path.startsWith(prefix)) {
      return undefined;
    }
    let s = path.substring(prefix.length);
    const slashIndex = s.indexOf("/");
    if (slashIndex !== -1) {
      s = s.substring(0, slashIndex);
    }
    if (GltfExtensionIssues.isNonnegativeInteger(s)) {
      return Number(s);
    }
    return undefined;
  }

  /**
   * Returns whether the given string is likely a nonnegative integer.
   *
   * @param s - The string
   * @returns The result
   */
  private static isNonnegativeInteger(s: string): boolean {
    return /^\d+$/.test(s);
  }

  /**
   * Tries to extract an extension name from the message that is generated by
   * the glTF Validator when it encounters an extension that is not supported.
   *
   * This makes assumptions about the structure of the message, and that it
   * is (verbatim) the message as it is generated by the glTF validator.
   *
   * @param message - The validation message
   * @returns The unsupported extension name, or `undefined` if the message
   * does not indicate an unsupported extension
   */
  private static extractUnsupportedExtensionName(
    message: string
  ): string | undefined {
    // Example:
    // "Cannot validate an extension as it is not supported by the validator: 'EXT_mesh_features'.",
    const prefix =
      "Cannot validate an extension as it is not supported by the validator: '";
    if (message.startsWith(prefix)) {
      const extensionName = message.substring(
        prefix.length,
        message.length - 2
      );
      return extensionName;
    }
    return undefined;
  }
}
