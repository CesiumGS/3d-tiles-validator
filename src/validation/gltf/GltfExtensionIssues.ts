import { ValidationIssue } from "../ValidationIssue";

/**
 * Functions for implementing filters on lists of validation issues,
 * to filter out issues that are obsolete due to glTF validation
 * steps that are performed by the 3D Tiles validator.
 */
export class GltfExtensionIssues {
  /**
   * Returns whether the given issue is a message about a potentially
   * unused object from the given top-level category, and this object
   * is actually used according to the given used indices.
   *
   * For example, when the given issue contains
   * - message: "This object may be unused."
   * - path: "/textures/1"
   * and the given usedIndices does contain '1', then this method
   * returns true.
   *
   * @param issue - The validation issue
   * @param topLevelName - The top level name, e.g. "textures" or "bufferViews"
   * @param usedIndices - The indices that are actually used
   * @returns Whether the issue is obsolete
   */
  static isObsoleteIssueAboutUnusedObject(
    issue: ValidationIssue,
    topLevelName: string,
    usedIndices: number[]
  ) {
    const message = issue.message;
    const path = issue.path;
    if (!message.startsWith("This object may be unused.")) {
      return false;
    }
    const prefix = "/" + topLevelName + "/";
    if (!path.startsWith(prefix)) {
      return;
    }
    const index = GltfExtensionIssues.extractIndex(topLevelName, path);
    if (index === undefined) {
      // This is making some assumptions about the path that
      // is generated by the glTF validator. Just print a
      // warning for the case that this ever breaks.
      console.warn(
        "Could not extract " + topLevelName + " index from path: " + path
      );
      return false;
    }
    const isUsed = usedIndices.includes(index);
    return isUsed;
  }

  /**
   * Tries to extract the index of the top-level element that is
   * indicated by the given JSON path.
   *
   * The given path is a JSON path that is generated by the glTF validator,
   * for example
   * "/images/4/mimeType"
   *
   * This function will omit the prefix, and (if present) the part
   * starting with the subsequent slash, and return the resulting
   * element ("4" in this example) as a number, if it is in fact
   * a number.
   *
   * If any aspect of this parsing does not succeed, then <code>undefined</code>
   * is returned. Yes, this could be solved with a 1.5MB "JSON path" dependency.
   * Let's be pragmatic for now.
   *
   * @param topLevelName - The name of the top-level type (e.g. 'images'
   * or 'accessors')
   * @param path - The path as generated by the glTF validator
   * @returns The index
   */
  static extractIndex(topLevelName: string, path: string): number | undefined {
    const prefix = "/" + topLevelName + "/";
    if (!path.startsWith(prefix)) {
      return undefined;
    }
    let s = path.substring(prefix.length);
    const slashIndex = s.indexOf("/");
    if (slashIndex !== -1) {
      s = s.substring(0, slashIndex);
    }
    if (GltfExtensionIssues.isNonnegativeInteger(s)) {
      return Number(s);
    }
    return undefined;
  }

  /**
   * Returns whether the given string is likely a nonnegative integer.
   *
   * @param s - The string
   * @returns The result
   */
  private static isNonnegativeInteger(s: string): boolean {
    return /^\d+$/.test(s);
  }

  /**
   * Returns whether the given validation issue is an issue that just
   * reports that the extension with the given name is not supported
   * by the glTF validator.
   *
   * @param issue - The validation issue
   * @param extensionName - The extension name
   * @returns The result
   */
  static isIssueAboutUnsupportedExtension(
    issue: ValidationIssue,
    extensionName: string
  ): boolean {
    const extensionNameInMessage =
      GltfExtensionIssues.extractUnsupportedExtensionName(issue.message);
    return extensionNameInMessage === extensionName;
  }

  /**
   * Tries to extract an extension name from the message that is generated by
   * the glTF Validator when it encounters an extension that is not supported.
   *
   * This makes assumptions about the structure of the message, and that it
   * is (verbatim) the message as it is generated by the glTF validator.
   *
   * @param message - The validation message
   * @returns The unsupported extension name, or `undefined` if the message
   * does not indicate an unsupported extension
   */
  private static extractUnsupportedExtensionName(
    message: string
  ): string | undefined {
    // Example:
    // "Cannot validate an extension as it is not supported by the validator: 'EXT_mesh_features'.",
    const prefix =
      "Cannot validate an extension as it is not supported by the validator: '";
    if (message.startsWith(prefix)) {
      const extensionName = message.substring(
        prefix.length,
        message.length - 2
      );
      return extensionName;
    }
    return undefined;
  }
}
