import { ValidationIssue } from "../ValidationIssue";
import { GltfData } from "./GltfData";

import { ValidationIssues } from "../../issues/ValidationIssues";
import { ValidationIssueSeverity } from "../ValidationIssueSeverity";
import { GltfExtensionIssues } from "./GltfExtensionIssues";

/**
 * Functions for implementing filters on lists of validation issues,
 * related to the KHR_texture_basisu extension
 */
export class GltfExtensionIssuesKhrTextureBasisu {
  /**
   * Process the given list of issues in view of KHR_texture_basisu.
   *
   * This will omit the issues that are considered obsolete due to
   * the lack of support for KHR_texture_basisu validation. If any
   * issues have been filtered out, a single, summarizing issue will
   * be added to the list, saying that the result was filtered.
   *
   * @param path - The path for validation issues
   * @param gltfData - The GltfData
   * @param causes - The causes
   * @returns The filtered causes
   */
  static async processCausesKhrTextureBasisu(
    path: string,
    gltfData: GltfData,
    causes: ValidationIssue[]
  ): Promise<ValidationIssue[]> {
    const gltf = gltfData.gltf;
    const khrTextureBasisuImageIndices =
      GltfExtensionIssuesKhrTextureBasisu.computeImageIndicesKhrTextureBasisu(
        gltf
      );

    const processedCauses: ValidationIssue[] = [];
    for (const cause of causes) {
      const remove =
        await GltfExtensionIssuesKhrTextureBasisu.shouldRemoveKhrTextureBasisu(
          khrTextureBasisuImageIndices,
          cause
        );
      if (!remove) {
        processedCauses.push(cause);
      }
    }

    if (causes.length > processedCauses.length) {
      const numRemoved = causes.length - processedCauses.length;
      const message =
        "Omitted " +
        numRemoved +
        " issues that have been " +
        "created due to the lack of support of the KHR_texture_basisu " +
        "extension in the glTF validator";
      const summaryIssue = ValidationIssues.VALIDATION_INFO(path, message);
      processedCauses.push(summaryIssue);
    }
    return processedCauses;
  }

  /**
   * Returns whether the given issue is an issue that should be removed
   * because it is caused by the lack of support of the KHR_texture_basisu
   * extension in the glTF validator.
   *
   * @param khrTextureBasisuImageIndices - The indices of images that
   * are used by the KHR_texture_basisu extension
   * @param issue - The validation issue
   * @returns Whether the issue should be removed
   */
  private static async shouldRemoveKhrTextureBasisu(
    khrTextureBasisuImageIndices: number[],
    issue: ValidationIssue
  ): Promise<boolean> {
    // Never remove errors!
    if (issue.severity === ValidationIssueSeverity.ERROR) {
      return false;
    }

    const message = issue.message;
    const path = issue.path;

    // Remove the message about the extension not being supported
    const isIssueAboutUnsupportedExtension =
      GltfExtensionIssues.isIssueAboutUnsupportedExtension(
        issue,
        "KHR_texture_basisu"
      );
    if (isIssueAboutUnsupportedExtension) {
      return true;
    }

    // Remove all INFO- and WARNING issues about
    // - invalid KTX MIME type
    // - unrecognized image format
    // - unused object
    // for issues that refer to a path starting with "/images/N"
    // where N is one of the images that are referred to by
    // the KHR_texture_basisu extension in any texture.
    if (
      message.startsWith("Invalid value 'image/ktx2'.") ||
      message.startsWith("Image format not recognized.") ||
      message.startsWith("This object may be unused.")
    ) {
      const imageIndex = GltfExtensionIssues.extractIndex("images", path);
      if (imageIndex === undefined) {
        // This is making some assumptions about the path that
        // is generated by the glTF validator. Just print a
        // warning for the case that this ever breaks.
        console.warn("Could not extract image index from path: " + path);
        return false;
      }
      if (khrTextureBasisuImageIndices.includes(imageIndex)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Compute the indices of all images that appear as any
   * <code>gltf.textures[i].extensions["KHR_texture_basisu"].source</code>.
   *
   * @param gltf - The glTF JSON object
   * @returns The image indices
   */
  private static computeImageIndicesKhrTextureBasisu(gltf: any): number[] {
    const imageIndices = [];
    const textures = gltf.textures ?? [];
    for (const texture of textures) {
      const extensions = texture.extensions ?? {};
      const khrTextureBasisuExtension = extensions["KHR_texture_basisu"] ?? {};
      const source = khrTextureBasisuExtension.source;
      if (typeof source === "number") {
        imageIndices.push(source);
      }
    }
    return imageIndices;
  }
}
