import { GltfData } from "../GltfData";

import { ValidationIssue } from "../../ValidationIssue";
import { ValidationIssueSeverity } from "../../ValidationIssueSeverity";
import { GltfExtensionIssues } from "../GltfExtensionIssues";

/**
 * A class for processing the list of issues that are generated by
 * the glTF validator, to filter out the issues that are obsolete
 * due to the validation from the ExtMeshFeaturesValidator.
 *
 * @internal
 */
export class ExtMeshFeaturesIssues {
  /**
   * Process the given list of validation issues, and possibly filer
   * out the issues that are obsolete due to the validation that
   * is performed by 'validateGltf'.
   *
   * @param path - The path for validation issues
   * @param gltfData - The GltfData objects
   * @param causes - The validation issues
   */
  static async processCauses(
    path: string,
    gltfData: GltfData,
    causes: ValidationIssue[]
  ): Promise<ValidationIssue[]> {
    const usedAccessorIndices =
      ExtMeshFeaturesIssues.computeUsedAccessorIndices(gltfData.gltf);
    const usedTextureIndices = ExtMeshFeaturesIssues.computeUsedTextureIndices(
      gltfData.gltf
    );

    const processedCauses: ValidationIssue[] = [];
    for (const cause of causes) {
      const remove = await ExtMeshFeaturesIssues.shouldRemove(
        usedAccessorIndices,
        usedTextureIndices,
        cause
      );
      if (!remove) {
        processedCauses.push(cause);
      }
    }
    return processedCauses;
  }

  /**
   * Returns whether the given issue is an issue that should be removed
   * because it is obsolete due to the validation that is performed by
   * 'validateGltf'
   *
   * @param usedAccessorIndices - The accessor indices that are
   * actually used by the extension, via feature ID attributes
   * @param usedTextureIndices - The texture indices that are
   * actually used by the extension, via feature ID textures
   * @param issue - The validation issue
   * @returns Whether the issue should be removed
   */
  private static async shouldRemove(
    usedAccessorIndices: number[],
    usedTextureIndices: number[],
    issue: ValidationIssue
  ): Promise<boolean> {
    // Never remove errors!
    if (issue.severity === ValidationIssueSeverity.ERROR) {
      return false;
    }

    // Remove the message about the extension not being supported
    const isIssueAboutUnsupportedExtension =
      GltfExtensionIssues.isIssueAboutUnsupportedExtension(
        issue,
        "EXT_mesh_features"
      );
    if (isIssueAboutUnsupportedExtension) {
      return true;
    }

    // Remove all INFO- and WARNING issues about unused objects
    // for buffer views and textures that are actually used
    // by the extension
    const isObsoleteAboutAccessor =
      GltfExtensionIssues.isObsoleteIssueAboutUnusedObject(
        issue,
        "accessors",
        usedAccessorIndices
      );
    if (isObsoleteAboutAccessor) {
      return true;
    }
    const isObsoleteAboutTexture =
      GltfExtensionIssues.isObsoleteIssueAboutUnusedObject(
        issue,
        "textures",
        usedTextureIndices
      );
    if (isObsoleteAboutTexture) {
      return true;
    }
    return false;
  }

  /**
   * Pragmatically drill into the given glTF object to find all accessor
   * indices that are used via feature ID attributes or as texture
   * coordinate accessors for feature ID textures.
   *
   * This will fall back to empty objects and arrays everywhere, and return
   * only the indices that are definitely known to be used.
   *
   * @param gltf - The glTF JSON object
   * @returns The accessor indices that are used by the
   * EXT_mesh_features extension
   */
  private static computeUsedAccessorIndices(gltf: any): number[] {
    const accessorIndices: number[] = [];
    const meshes = gltf.meshes ?? [];
    for (const mesh of meshes) {
      const primitives = mesh.primitives ?? [];
      for (const primitive of primitives) {
        const extensions = primitive.extensions ?? {};
        const extension = extensions["EXT_mesh_features"] ?? {};
        const featureIds = extension.featureIds ?? [];
        for (const featureId of featureIds) {
          const attributeAccessorIndex = featureId.attribute;
          if (typeof attributeAccessorIndex === "number") {
            accessorIndices.push(attributeAccessorIndex);
          }
          const texture = featureId.texture ?? {};
          const texcoordAccessorIndex = texture.texCoord;
          if (typeof texcoordAccessorIndex === "number") {
            accessorIndices.push(texcoordAccessorIndex);
          }
        }
      }
    }
    return accessorIndices;
  }

  /**
   * Pragmatically drill into the given glTF object to find all texture
   * indices that are used via feature ID textures
   *
   * This will fall back to empty objects and arrays everywhere, and return
   * only the indices that are definitely known to be used.
   *
   * @param gltf - The glTF JSON object
   * @returns The texture indices that are used by the
   * EXT_mesh_features extension
   */
  private static computeUsedTextureIndices(gltf: any): number[] {
    const textureIndices: number[] = [];
    const meshes = gltf.meshes ?? [];
    for (const mesh of meshes) {
      const primitives = mesh.primitives ?? [];
      for (const primitive of primitives) {
        const extensions = primitive.extensions ?? {};
        const extension = extensions["EXT_mesh_features"] ?? {};
        const featureIds = extension.featureIds ?? [];
        for (const featureId of featureIds) {
          const texture = featureId.texture ?? {};
          const textureIndex = texture.index;
          if (typeof textureIndex === "number") {
            textureIndices.push(textureIndex);
          }
        }
      }
    }
    return textureIndices;
  }
}
